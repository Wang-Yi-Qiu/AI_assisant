/**
 * å›¾è¡¨ç±»å‹é€‰æ‹©é¡µé¢
 * æ”¯æŒå¤šç§å›¾è¡¨ç±»å‹çš„é€‰æ‹©å’Œé¢„è§ˆï¼Œé›†æˆAIæ™ºèƒ½æ¨è
 * @module ChartTypeSelectorPage
 */

import router from '@ohos.router';
import { getOriginalData, setChartOption, setChartFromParsedData } from './ChartPage';
import { generateChart, ChartConfig, UserData, CSVData } from '../utils/aiService';
import { ParsedData } from '../utils/fileDataParser';
import {
  dataVisualizationService,
  ChartType as DVChartType,
  ChartRecommendation,
  ChartTypeInfo,
  DataType
} from '../utils/dataVisualizationService';

// è¾…åŠ©å‡½æ•°ï¼šå®‰å…¨åœ°è®¿é—®UserDataçš„dataå±æ€§
function getDataFromUserData(userData: UserData): object[] | null {
  if (typeof userData === 'object' && userData !== null) {
    const csvData = userData as CSVData;
    return csvData.data || null;
  }
  return null;
}

// å›¾è¡¨ç±»å‹å®šä¹‰ï¼ˆä¸æ•°æ®å¯è§†åŒ–æœåŠ¡ä¿æŒå…¼å®¹ï¼‰
class ChartTypeSelectorInfo {
  id: string = '';
  name: string = '';
  description: string = '';
  icon: string = '';
  example: string = '';
  supported: boolean = true;
  recommended?: boolean;
  score?: number;
  reason?: string;
}

// å®šä¹‰å¢å¼ºç”¨æˆ·æ•°æ®æ¥å£
interface EnhancedUserData {
  originalData: UserData;
  chartType: string;
}

@Entry
@Component
export struct ChartTypeSelectorPage {
  @State chartTypes: ChartTypeSelectorInfo[] = [];
  @State recommendations: ChartRecommendation[] = [];
  @State selectedType: string = '';
  @State isLoading: boolean = true;
  @State errorMessage: string = '';
  @State parsedData: ParsedData | null = null;
  @State useLocalData: boolean = false;

  aboutToAppear(): void {
    console.info('[ChartTypeSelectorPage] é¡µé¢åˆå§‹åŒ–');
    this.loadChartTypes();
  }

  /**
   * åŠ è½½å›¾è¡¨ç±»å‹ï¼ˆåŒ…å«æ™ºèƒ½æ¨èï¼‰
   */
  async loadChartTypes(): Promise<void> {
    try {
      this.isLoading = true;
      this.errorMessage = '';

      // æ£€æŸ¥æ˜¯å¦æœ‰è§£æåçš„æ•°æ®
      const params = router.getParams() as any;
      if (params && params.parsedData) {
        this.parsedData = params.parsedData as ParsedData;
        this.useLocalData = true;
        console.info('[ChartTypeSelectorPage] ä½¿ç”¨æœ¬åœ°è§£ææ•°æ®:', this.parsedData.fileName);

        // ä½¿ç”¨æœ¬åœ°æ•°æ®æ¨èå›¾è¡¨ç±»å‹
        this.recommendations = dataVisualizationService.recommendChartTypesFromParsedData(this.parsedData);
      } else {
        // è·å–åŸå§‹æ•°æ®
        const originalData = getOriginalData();
        if (!originalData) {
          throw new Error('æ²¡æœ‰æ‰¾åˆ°åŸå§‹æ•°æ®ï¼Œè¯·å…ˆä¸Šä¼ æ•°æ®');
        }

        console.info('[ChartTypeSelectorPage] å¼€å§‹åˆ†ææ•°æ®å¹¶æ¨èå›¾è¡¨ç±»å‹');

        // è·å–AIæ¨èçš„å›¾è¡¨ç±»å‹
        this.recommendations = dataVisualizationService.recommendChartTypes(originalData);
      }

      console.info('[ChartTypeSelectorPage] æ¨èç»“æœ:', this.recommendations.length);

      // è·å–æ‰€æœ‰æ”¯æŒçš„å›¾è¡¨ç±»å‹
      const supportedTypes = dataVisualizationService.getSupportedChartTypes();

      // å›¾æ ‡æ˜ å°„
      const iconMap = new Map<string, string>([
        ['bar', 'ğŸ“Š'],
        ['line', 'ğŸ“ˆ'],
        ['scatter', 'âš¡'],
        ['pie', 'ğŸ¥§'],
        ['area', 'ğŸ“‰'],
        ['heatmap', 'ğŸ”¥']
      ]);

      // ç¤ºä¾‹æ˜ å°„
      const exampleMap = new Map<string, string>([
        ['bar', 'æœˆåº¦é”€å”®é¢å¯¹æ¯”'],
        ['line', 'è‚¡ç¥¨ä»·æ ¼èµ°åŠ¿'],
        ['scatter', 'èº«é«˜ä½“é‡å…³ç³»'],
        ['pie', 'å¸‚åœºä»½é¢åˆ†å¸ƒ'],
        ['area', 'ç”¨æˆ·å¢é•¿è¶‹åŠ¿'],
        ['heatmap', 'ç½‘ç«™è®¿é—®çƒ­åŠ›å›¾']
      ]);

      // è½¬æ¢ä¸ºUIé€‰é¡¹å¹¶æ ‡è®°æ¨è
      this.chartTypes = supportedTypes.map((type, index: number): ChartTypeSelectorInfo => {
        const recommendation = this.recommendations.find(r => r.type === type.type);

        const chartTypeInfo = new ChartTypeSelectorInfo();
        chartTypeInfo.id = type.type;
        chartTypeInfo.name = type.name;
        chartTypeInfo.description = type.description;
        chartTypeInfo.icon = iconMap.get(type.type) || 'ğŸ“Š';
        chartTypeInfo.example = exampleMap.get(type.type) || 'æ•°æ®åˆ†æå›¾è¡¨';
        chartTypeInfo.supported = true;
        chartTypeInfo.recommended = recommendation ? recommendation.confidence === 'high' : false;
        chartTypeInfo.score = recommendation?.score;
        chartTypeInfo.reason = recommendation?.reason;

        return chartTypeInfo;
      });

      // æŒ‰æ¨èç¨‹åº¦å’Œåˆ†æ•°æ’åº
      this.chartTypes.sort((a, b) => {
        if (a.recommended && !b.recommended) return -1;
        if (!a.recommended && b.recommended) return 1;
        if (a.score && b.score) return b.score - a.score;
        return 0;
      });

      console.info('[ChartTypeSelectorPage] å›¾è¡¨ç±»å‹åŠ è½½å®Œæˆï¼Œå…±', this.chartTypes.length, 'ç§');

    } catch (error) {
      console.error('[ChartTypeSelectorPage] åŠ è½½å›¾è¡¨ç±»å‹å¤±è´¥:', error);
      this.errorMessage = error instanceof Error ? error.message : 'åŠ è½½å¤±è´¥';

      // é™çº§å¤„ç†ï¼šä½¿ç”¨åŸºæœ¬å›¾è¡¨ç±»å‹
      this.fallbackToBasicTypes();
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * é™çº§å¤„ç†ï¼šä½¿ç”¨åŸºæœ¬å›¾è¡¨ç±»å‹
   */
  private fallbackToBasicTypes(): void {
    this.chartTypes = [
      {
        id: 'bar',
        name: 'æŸ±çŠ¶å›¾',
        description: 'é€‚åˆæ¯”è¾ƒä¸åŒç±»åˆ«çš„æ•°å€¼å¤§å°',
        icon: 'ğŸ“Š',
        example: 'æœˆåº¦é”€å”®é¢å¯¹æ¯”',
        supported: true
      },
      {
        id: 'line',
        name: 'æŠ˜çº¿å›¾',
        description: 'é€‚åˆå±•ç¤ºæ•°æ®éšæ—¶é—´çš„å˜åŒ–è¶‹åŠ¿',
        icon: 'ğŸ“ˆ',
        example: 'è‚¡ç¥¨ä»·æ ¼èµ°åŠ¿',
        supported: true
      },
      {
        id: 'pie',
        name: 'é¥¼å›¾',
        description: 'é€‚åˆå±•ç¤ºæ•°æ®çš„å æ¯”å…³ç³»',
        icon: 'ğŸ¥§',
        example: 'å¸‚åœºä»½é¢åˆ†å¸ƒ',
        supported: true
      },
      {
        id: 'scatter',
        name: 'æ•£ç‚¹å›¾',
        description: 'é€‚åˆå±•ç¤ºä¸¤ä¸ªå˜é‡ä¹‹é—´çš„å…³ç³»',
        icon: 'âš¡',
        example: 'èº«é«˜ä½“é‡å…³ç³»',
        supported: true
      },
      {
        id: 'area',
        name: 'é¢ç§¯å›¾',
        description: 'é€‚åˆå±•ç¤ºæ•°æ®çš„ç´¯ç§¯å˜åŒ–',
        icon: 'ğŸ“‰',
        example: 'ç”¨æˆ·å¢é•¿è¶‹åŠ¿',
        supported: true
      },
      {
        id: 'radar',
        name: 'é›·è¾¾å›¾',
        description: 'é€‚åˆå¤šç»´åº¦æ•°æ®çš„å¯¹æ¯”åˆ†æ',
        icon: 'ğŸ¯',
        example: 'äº§å“èƒ½åŠ›è¯„ä¼°',
        supported: true
      }
    ];
    console.info('[ChartTypeSelectorPage] ä½¿ç”¨é™çº§æ–¹æ¡ˆï¼Œåˆå§‹åŒ–åŸºæœ¬å›¾è¡¨ç±»å‹');
  }

  /**
   * é€‰æ‹©å›¾è¡¨ç±»å‹
   */
  selectChartType(chartType: ChartTypeSelectorInfo): void {
    if (!chartType.supported) {
      console.warn('[ChartTypeSelectorPage] å›¾è¡¨ç±»å‹ä¸æ”¯æŒ:', chartType.id);
      return;
    }

    this.selectedType = chartType.id;
    console.info('[ChartTypeSelectorPage] é€‰æ‹©å›¾è¡¨ç±»å‹:', chartType.id, chartType.name);

    // å¦‚æœæœ‰æ¨èä¿¡æ¯ï¼Œæ‰“å°æ¨èç†ç”±
    if (chartType.reason) {
      console.info('[ChartTypeSelectorPage] æ¨èç†ç”±:', chartType.reason);
    }
  }

  /**
   * ç¡®è®¤é€‰æ‹©å¹¶ç”Ÿæˆå›¾è¡¨ï¼ˆå¢å¼ºç‰ˆæœ¬ï¼‰
   */
  async confirmSelection(): Promise<void> {
    if (!this.selectedType || this.isLoading) {
      return;
    }

    try {
      console.info('[ChartTypeSelectorPage] ========== å¼€å§‹ç”Ÿæˆ', this.selectedType, 'å›¾è¡¨ ==========');

      this.isLoading = true;

      let chartConfig: ChartConfig;

      if (this.useLocalData && this.parsedData) {
        // ä½¿ç”¨æœ¬åœ°è§£æçš„æ•°æ®
        console.info('[ChartTypeSelectorPage] ä½¿ç”¨æœ¬åœ°æ•°æ®ç”Ÿæˆå›¾è¡¨');

        if (!this.parsedData) {
          throw new Error('æ²¡æœ‰è§£æåçš„æ•°æ®ç”¨äºç”Ÿæˆå›¾è¡¨');
        }

        // å°†é€‰æ‹©çš„ç±»å‹è½¬æ¢ä¸ºæšä¸¾ç±»å‹
        const selectedDVType = this.selectedType as DVChartType;

        // ç›´æ¥ä½¿ç”¨æœ¬åœ°æ•°æ®ç”Ÿæˆå›¾è¡¨é…ç½®
        chartConfig = dataVisualizationService.createChartConfigFromParsedData(this.parsedData, selectedDVType);
        console.info('[ChartTypeSelectorPage] æœ¬åœ°å›¾è¡¨é…ç½®åˆ›å»ºå®Œæˆ');

        // è·³è½¬åˆ°å›¾è¡¨é¡µé¢å¹¶è®¾ç½®æœ¬åœ°æ•°æ®
        router.pushUrl({
          url: 'pages/ChartPage'
        });

        // è®¾ç½®å›¾è¡¨é…ç½®
        setChartFromParsedData(this.parsedData, selectedDVType);

      } else {
        // ä½¿ç”¨åŸæœ‰é€»è¾‘
        console.info('[ChartTypeSelectorPage] ä½¿ç”¨åŸå§‹æ•°æ®ç”Ÿæˆå›¾è¡¨');

        // æ£€æŸ¥æ˜¯å¦æœ‰åŸå§‹æ•°æ®
        const originalData = getOriginalData();
        if (!originalData) {
          throw new Error('æ²¡æœ‰åŸå§‹æ•°æ®ç”¨äºç”Ÿæˆå›¾è¡¨');
        }
        const dataRows = getDataFromUserData(originalData);
        if (!dataRows || dataRows.length === 0) {
          throw new Error('æ²¡æœ‰åŸå§‹æ•°æ®ç”¨äºç”Ÿæˆå›¾è¡¨');
        }

        // å°è¯•ä½¿ç”¨æ•°æ®å¯è§†åŒ–æœåŠ¡ç”Ÿæˆå›¾è¡¨
        try {
          // å°†é€‰æ‹©çš„ç±»å‹è½¬æ¢ä¸ºæšä¸¾ç±»å‹
          const selectedDVType = this.selectedType as DVChartType;

          // åˆ›å»ºå¢å¼ºé…ç½®
          const enhancedConfig: ChartConfig = dataVisualizationService.createEnhancedChartConfig(
            originalData,
            selectedDVType
          );
          console.info('[ChartTypeSelectorPage] å¢å¼ºé…ç½®åˆ›å»ºå®Œæˆ');

          // è½¬æ¢ä¸ºEChartsé…ç½®
          chartConfig = dataVisualizationService.convertToEChartsConfig(enhancedConfig, originalData);
          console.info('[ChartTypeSelectorPage] EChartsé…ç½®è½¬æ¢å®Œæˆ');

        } catch (dvError) {
          console.warn('[ChartTypeSelectorPage] æ•°æ®å¯è§†åŒ–æœåŠ¡ç”Ÿæˆå¤±è´¥ï¼Œå›é€€åˆ°AIæœåŠ¡:', dvError);

          // é™çº§åˆ°åŸæœ‰AIæœåŠ¡
          const userData: UserData = {
            originalData: originalData,
          chartType: this.selectedType
        } as EnhancedUserData;

        chartConfig = await generateChart(userData);
        console.info('[ChartTypeSelectorPage] AIæœåŠ¡ç”Ÿæˆå›¾è¡¨é…ç½®æˆåŠŸ');
      }

      // è®¾ç½®å›¾è¡¨é…ç½®
      setChartOption(chartConfig, originalData);
      console.info('[ChartTypeSelectorPage] å›¾è¡¨é…ç½®å·²è®¾ç½®ï¼Œå‡†å¤‡è¿”å›');

      // ç›´æ¥è¿”å›ä¸Šä¸€é¡µï¼ˆä»ChartPageè¿›å…¥çš„ï¼‰
      router.back();

      console.info('[ChartTypeSelectorPage] å·²è¿”å›å›¾è¡¨é¡µé¢');

    } catch (error) {
      console.error('[ChartTypeSelectorPage] ç”Ÿæˆå›¾è¡¨å¤±è´¥:', error);

      // æ˜¾ç¤ºé”™è¯¯æç¤º
      this.errorMessage = `ç”Ÿæˆå¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`;

      // 3ç§’åæ¸…é™¤é”™è¯¯ä¿¡æ¯
      setTimeout(() => {
        this.errorMessage = '';
      }, 3000);

    } finally {
      this.isLoading = false;
    }
  }

  /**
   * è¿”å›ä¸Šä¸€é¡µ
   */
  goBack(): void {
    router.back();
  }

  /**
   * æ„å»ºå›¾è¡¨ç±»å‹å¡ç‰‡
   */
  @Builder
  ChartTypeCard(chartType: ChartTypeSelectorInfo): void {
    Column() {
      // æ¨èæ ‡ç­¾å’Œå›¾æ ‡
      Stack() {
        // å›¾æ ‡
        Text(chartType.icon)
          .fontSize(32)
          .margin({ top: 8 })

        // æ¨èæ ‡ç­¾
        if (chartType.recommended) {
          Text('æ¨è')
            .fontSize(10)
            .fontColor(Color.White)
            .backgroundColor('#FF6B35')
            .padding({ left: 6, right: 6, top: 2, bottom: 2 })
            .borderRadius(8)
            .position({ x: 60, y: 0 })
            .zIndex(1)
        }
      }
      .alignContent(Alignment.TopEnd)
      .width('100%')
      .height(50)
      .margin({ bottom: 8 })

      // åç§°
      Text(chartType.name)
        .fontSize(16)
        .fontWeight(FontWeight.Bold)
        .fontColor(Color.White)
        .textAlign(TextAlign.Center)
        .width('100%')
        .margin({ bottom: 6 })

      // æè¿°
      Text(chartType.description)
        .fontSize(12)
        .fontColor('#CCCCCC')
        .textAlign(TextAlign.Center)
        .width('100%')
        .maxLines(2)
        .textOverflow({ overflow: TextOverflow.Ellipsis })
        .margin({ bottom: 8 })

      // ç¤ºä¾‹
      Text(chartType.example)
        .fontSize(10)
        .fontColor('#999999')
        .fontStyle(FontStyle.Italic)
        .textAlign(TextAlign.Center)
        .width('100%')
        .maxLines(1)
        .textOverflow({ overflow: TextOverflow.Ellipsis })

      // æ¨èç†ç”±
      if (chartType.reason && chartType.recommended) {
        Text(chartType.reason)
          .fontSize(9)
          .fontColor('#007DFF')
          .textAlign(TextAlign.Center)
          .width('100%')
          .maxLines(2)
          .textOverflow({ overflow: TextOverflow.Ellipsis })
          .margin({ top: 4 })
      }

      // åˆ†æ•°æ˜¾ç¤ºï¼ˆç”¨äºè°ƒè¯•ï¼‰
      if (chartType.score) {
        Text(`åŒ¹é…åº¦: ${(chartType.score * 100).toFixed(0)}%`)
          .fontSize(8)
          .fontColor('#666666')
          .textAlign(TextAlign.Center)
          .width('100%')
          .margin({ top: 2 })
      }
    }
    .width('48%')
    .padding(12)
    .backgroundColor(this.selectedType === chartType.id ? '#007DFF' : '#252525')
    .borderRadius(12)
    .border({
      width: chartType.recommended ? 2 : 1,
      color: this.selectedType === chartType.id ? '#007DFF' : (chartType.recommended ? '#FF6B35' : '#333333')
    })
    .onClick(() => {
      this.selectChartType(chartType);
    })
    .animation({
      duration: 200,
      curve: Curve.EaseInOut
    })
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      Row() {
        Button() {
          Text('â†')
            .fontSize(24)
            .fontColor(Color.White)
        }
        .type(ButtonType.Normal)
        .backgroundColor(Color.Transparent)
        .width(40)
        .height(40)
        .onClick(() => {
          this.goBack();
        })

        Blank()

        Text('é€‰æ‹©å›¾è¡¨ç±»å‹')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor(Color.White)

        Blank()
          .width(40)
      }
      .width('100%')
      .height(56)
      .padding({ left: 15, right: 15 })
      .justifyContent(FlexAlign.SpaceBetween)
      .alignItems(VerticalAlign.Center)

      // å¯æ»šåŠ¨å†…å®¹åŒºåŸŸ
      Scroll() {
        Column() {
          // åŠ è½½çŠ¶æ€
          if (this.isLoading) {
            Column() {
              Text('âœ¨')
                .fontSize(48)
                .margin({ bottom: 15 })
              LoadingProgress()
                .width(40)
                .height(40)
                .margin({ bottom: 15 })
              Text('æ­£åœ¨åˆ†ææ•°æ®...')
                .fontSize(16)
                .fontColor(Color.Gray)
              Text('AI æ­£åœ¨ä¸ºæ‚¨çš„æ•°æ®æ¨èæœ€åˆé€‚çš„å›¾è¡¨ç±»å‹')
                .fontSize(14)
                .fontColor('#CCCCCC')
                .textAlign(TextAlign.Center)
                .margin({ top: 8 })
            }
            .width('100%')
            .height(300)
            .justifyContent(FlexAlign.Center)
            .alignItems(HorizontalAlign.Center)
          }
          // é”™è¯¯çŠ¶æ€
          else if (this.errorMessage && this.chartTypes.length === 0) {
            Column() {
              Text('âš ï¸')
                .fontSize(48)
                .margin({ bottom: 15 })
              Text(this.errorMessage)
                .fontSize(16)
                .fontColor('#FF6B6B')
                .textAlign(TextAlign.Center)
                .padding({ left: 20, right: 20 })
                .margin({ bottom: 20 })
              Button() {
                Text('é‡è¯•')
                  .fontColor(Color.White)
              }
              .type(ButtonType.Normal)
              .backgroundColor('#007DFF')
              .onClick(() => this.loadChartTypes())
            }
            .width('100%')
            .height(300)
            .justifyContent(FlexAlign.Center)
            .alignItems(HorizontalAlign.Center)
          }
          // å›¾è¡¨ç±»å‹é€‰æ‹©ç½‘æ ¼
          else {
            // AI æ¨èæ ‡é¢˜
            if (this.recommendations.length > 0) {
              Column() {
                Row() {
                  Text('ğŸ¯')
                    .fontSize(20)
                    .margin({ right: 8 })
                  Text('AI æ¨è')
                    .fontSize(18)
                    .fontWeight(FontWeight.Bold)
                    .fontColor(Color.White)
                }
                .width('100%')
                .alignItems(VerticalAlign.Center)
                .margin({ bottom: 15 })

                // æ¨èçš„å›¾è¡¨ç±»å‹
                Flex({ wrap: FlexWrap.Wrap, justifyContent: FlexAlign.SpaceBetween }) {
                  ForEach(
                    this.chartTypes.filter(option => option.recommended).slice(0, 4),
                    (option: ChartTypeSelectorInfo, index?: number) => {
                      this.ChartTypeCard(option)
                    }
                  )
                }
                .width('100%')
                .margin({ bottom: 25 })
              }
              .width('100%')
              .padding({ bottom: 10 })
            }

            // æ‰€æœ‰å›¾è¡¨ç±»å‹æ ‡é¢˜
            Column() {
              Row() {
                Text('ğŸ“Š')
                  .fontSize(20)
                  .margin({ right: 8 })
                Text('æ‰€æœ‰å›¾è¡¨ç±»å‹')
                  .fontSize(18)
                  .fontWeight(FontWeight.Bold)
                  .fontColor(Color.White)
              }
              .width('100%')
              .alignItems(VerticalAlign.Center)
              .margin({ bottom: 15 })

              // æ‰€æœ‰å›¾è¡¨ç±»å‹ç½‘æ ¼
              Flex({ wrap: FlexWrap.Wrap, justifyContent: FlexAlign.SpaceBetween }) {
                ForEach(this.chartTypes, (option: ChartTypeSelectorInfo, index?: number) => {
                  this.ChartTypeCard(option)
                })
              }
              .width('100%')
              .margin({ bottom: 30 })
            }
            .width('100%')

            // é”™è¯¯æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼Œä½†ä¸å½±å“æ˜¾ç¤ºï¼‰
            if (this.errorMessage) {
              Column() {
                Text('âš ï¸')
                  .fontSize(16)
                  .margin({ bottom: 8 })
                Text(this.errorMessage)
                  .fontSize(14)
                  .fontColor('#FF6B6B')
                  .textAlign(TextAlign.Center)
              }
              .width('100%')
              .margin({ bottom: 20 })
            }

            // ç¡®è®¤æŒ‰é’®
            Button(this.selectedType ? 'ç”Ÿæˆå›¾è¡¨' : 'è¯·é€‰æ‹©å›¾è¡¨ç±»å‹')
              .width('80%')
              .height(50)
              .fontSize(16)
              .fontWeight(FontWeight.Bold)
              .backgroundColor(this.selectedType ? '#007DFF' : '#666666')
              .fontColor(Color.White)
              .borderRadius(25)
              .enabled(this.selectedType !== '' && !this.isLoading)
              .margin({ top: 20, bottom: 30 })
              .onClick(() => {
                this.confirmSelection();
              })

            // åº•éƒ¨æç¤º
            Column() {
              Text('ğŸ’¡')
                .fontSize(16)
                .margin({ bottom: 8 })
              Text('é€‰æ‹©ä¸åŒçš„å›¾è¡¨ç±»å‹æ¥å±•ç¤ºæ‚¨çš„æ•°æ®')
                .fontSize(14)
                .fontColor('#CCCCCC')
                .textAlign(TextAlign.Center)
              Text('AI ä¼šæ ¹æ®æ‚¨çš„æ•°æ®ç‰¹ç‚¹è‡ªåŠ¨æ¨èæœ€é€‚åˆçš„å›¾è¡¨')
                .fontSize(12)
                .fontColor('#999999')
                .textAlign(TextAlign.Center)
                .margin({ top: 4 })
            }
            .width('100%')
            .margin({ top: 20, bottom: 20 })
          }
        }
        .width('100%')
        .padding({ left: 15, right: 15, top: 20, bottom: 20 })
      }
      .layoutWeight(1)
      .width('100%')
      .scrollable(ScrollDirection.Vertical)
      .scrollBar(BarState.Auto)
      .edgeEffect(EdgeEffect.Spring)

      // åº•éƒ¨åŠ è½½é®ç½©
      Column() {
        LoadingProgress()
          .width(30)
          .height(30)
          .margin({ bottom: 8 })
        Text('æ­£åœ¨ç”Ÿæˆå›¾è¡¨...')
          .fontSize(14)
          .fontColor(Color.Gray)
      }
      .width('100%')
      .padding(20)
      .backgroundColor('#1C1C1C')
      .justifyContent(FlexAlign.Center)
      .alignItems(HorizontalAlign.Center)
      .visibility(this.isLoading && this.chartTypes.length > 0 ? Visibility.Visible : Visibility.None)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#1C1C1C')
  }
}